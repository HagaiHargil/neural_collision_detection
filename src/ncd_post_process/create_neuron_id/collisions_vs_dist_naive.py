"""
Aggregation of tools to analyze the graphs generated by
'graph_parsing.py'.
"""
import pathlib

import attr
from attr.validators import instance_of
import networkx as nx
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import scipy.stats
import numba

from ncd_post_process.graph_parsing import CollisionNode


@attr.s
class CollisionsDistNaive:
    """Calculate and plot the collision counts as a function of
    the topological distance of the neuron. This class is "naive" since it doesn't
    interpolate the neural coordinates, it uses the raw output from the
    Neurolucida files as its input.

    Parameters
    ----------
    graph : nx.Graph
        A parsed graph that was generated by networkx and ``NeuronToGraph`` in
        ``graph_parsing.py``.
    neuron_name : str
        The label of the neuron
    normalize_collisions_by : int
        Number of possible locations that the neuron could've been in. This factor turns
        the number of collisions into the probability of collision.
    """

    graph = attr.ib(validator=instance_of(nx.Graph))
    neuron_name = attr.ib(default="neuron", validator=instance_of(str))
    normalize_collisions_by = attr.ib(default=100_000, validator=instance_of(int))
    num_of_nodes = attr.ib(init=False)
    parsed_axon = attr.ib(init=False)
    parsed_dend = attr.ib(init=False)

    def __attrs_post_init__(self):
        self.num_of_nodes = self.graph.number_of_nodes()
        coll_ax = np.zeros(self.num_of_nodes, dtype=np.uint64)
        coll_dend = coll_ax.copy()
        dist_ax = np.zeros(self.num_of_nodes, dtype=np.float64)
        dist_dend = dist_ax.copy()
        self.parsed_axon = pd.DataFrame({"coll": coll_ax, "dist": dist_ax})
        self.parsed_dend = pd.DataFrame({"coll": coll_dend, "dist": dist_dend})

    @classmethod
    def from_graph(cls, fname: pathlib.Path):
        """Instantiate from an existing graph file by deserializing it."""
        try:
            graph = nx.readwrite.gml.read_gml(
                str(fname), destringizer=CollisionNode.from_str
            )
        except FileNotFoundError:
            raise
        else:
            return cls(graph)

    def run(self):
        """Run analysis pipeline."""
        self._populate_collisions()
        for data, neurite in zip((self.parsed_axon, self.parsed_dend), ("axon", "dend")):
            self._plot_jointplot(data, neurite)
            data["coll_normed"] = self._normalize_by_density(data)
            self._plot_jointplot(data, neurite, with_norm=True)

    def _populate_collisions(self):
        """Traverse a specific graph and find the number of
        collisions in it as a function of the topological distance
        from the cell body.
        """
        idx_axon, idx_dend = 0, 0
        for node in self.graph.nodes():
            if node.tree_type == "Axon":
                self.parsed_axon.loc[idx_axon, "coll"] = node.collisions
                self.parsed_axon.loc[idx_axon, "dist"] = node.dist_to_body
                idx_axon += 1
            else:
                self.parsed_dend.loc[idx_dend, "coll"] = node.collisions
                self.parsed_dend.loc[idx_dend, "dist"] = node.dist_to_body
                idx_dend += 1

        self.parsed_axon = self.parsed_axon.loc[:idx_axon, :]
        self.parsed_dend = self.parsed_dend.loc[:idx_dend, :]

    def _normalize_by_density(self, data):
        """Takes the parsed graph data and normalizes the collision counts by the
        neural density at that distance, since the more neuron there is the more likely
        it is for it to encounter blood vessels. This function actually returns the chance
        for a (normalized) collision, since it also divided the result by the number of
        NCD iterations.
        """
        dist_int = data["dist"].to_numpy().astype(np.int64)
        bincounts = np.bincount(dist_int, minlength=dist_int.max())
        normed = norm_colls(bincounts, dist_int, data["coll"].to_numpy())
        return normed / self.normalize_collisions_by

    def _plot_jointplot(self, data, neurite, with_norm=False):
        """Creates a jointplot with hexagons which show the probability of collision
        as a function of the topological distance from the soma.
        """
        labels_and_colors = {'axon': ("C2", "Axonal"), 'dend': ("C1", "Dendritic")}
        new_ycol_name = f"{labels_and_colors[neurite][1]} chance for collision"
        data = data.copy().rename(
            {"dist": "Length of branch [um]", "coll": new_ycol_name, "coll_normed": f"{new_ycol_name} (normalized)"}, axis=1
        )
        data.loc[:, new_ycol_name] = (
            data.loc[:, new_ycol_name] / self.normalize_collisions_by
        )
        plt.rcParams.update({"font.size": 22})
        if with_norm:
            y_col = new_ycol_name + " (normalized)"
            fname = f"results/for_article/fig2/{self.neuron_name}_colls_vs_dist_normed_{neurite}.pdf"
        else:
            y_col = new_ycol_name
            fname = f"results/for_article/fig2/{self.neuron_name}_colls_vs_dist_no_normed_{neurite}.pdf"

        ax = sns.jointplot(
            "Length of branch [um]",
            y_col,
            data=data,
            kind="hex",
            height=8,
            color=labels_and_colors[neurite][0],
        )
        plt.subplots_adjust(left=0.11)
        ax.savefig(
            fname,
            transparent=True,
            dpi=300,
        )


@numba.jit(nopython=True, parallel=True)
def norm_colls(bincounts, distances, collisions):
    """Iterate over the collision counts and normalize
    them by the neural density at that distance.
    """
    normed_collisions = np.zeros_like(collisions)
    for idx in numba.prange(len(collisions)):
        normed_collisions[idx] = collisions[idx] / bincounts[distances[idx]]
    return normed_collisions


if __name__ == "__main__":
    neuron_names = [
        "AP120410_s1c1",
        "AP120410_s3c1",
        "AP120412_s3c2",
        "AP120416_s3c1",
        "AP120419_s1c1",
        "AP120420_s1c1",
        "AP120420_s2c1",
        "AP120507_s3c1",
        "AP120510_s1c1",
        "AP120522_s3c1",
        "AP120524_s2c1",
        "AP120614_s1c2",
        "AP130312_s1c1",
        "AP131105_s1c1",
    ]
    # fig, ax = plt.subplots(2, 2)
    # fig.suptitle('Collisions as a function of topological distance from soma\nAxon collisions in blue, dendritic in orange')
    # for neuron, axx in zip(neuron_names, ax.flatten()):
    for neuron in neuron_names:
        graph_fname = (
            pathlib.Path("/data/neural_collision_detection/results/2019_2_10")
            / f"graph_{neuron}_with_collisions.gml"
        )
        try:
            coll_dist = CollisionsDistNaive.from_graph(graph_fname)
        except FileNotFoundError:
            continue
        coll_dist.neuron_name = neuron
        coll_dist.run()
    # fig.tight_layout()
    plt.show(block=False)
