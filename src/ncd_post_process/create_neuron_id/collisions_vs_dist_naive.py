"""
Aggregation of tools to analyze the graphs generated by
'graph_parsing.py'.
"""
import pathlib

import attr
from attr.validators import instance_of
import networkx as nx
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import scipy.stats
import numba

from ncd_post_process.graph_parsing import CollisionNode


@attr.s
class CollisionsDistNaive:
    """Calculate and plot the collision counts as a function of
    the topological distance of the neuron. This class is "naive" since it doesn't
    interpolate the neural coordinates, it uses the raw output from the
    Neurolucida files as its input.

    To use it, run the "run" method to first create the necessary data structures.
    The "plot_all()" method can show the data and write it to disk.

    Parameters
    ----------
    graph : nx.Graph
        A parsed graph that was generated by networkx and ``NeuronToGraph`` in
        ``graph_parsing.py``.
    neuron_name : str
        The label of the neuron
    normalize_collisions_by : int
        Number of possible locations that the neuron could've been in. This factor turns
        the number of collisions into the probability of collision.
    """

    graph = attr.ib(validator=instance_of(nx.Graph))
    neuron_name = attr.ib(default="neuron", validator=instance_of(str))
    normalize_collisions_by = attr.ib(default=100_000, validator=instance_of(int))
    num_of_nodes = attr.ib(init=False)
    parsed_axon = attr.ib(init=False)
    parsed_dend = attr.ib(init=False)

    def __attrs_post_init__(self):
        self.num_of_nodes = self.graph.number_of_nodes()
        coll_ax = np.zeros(self.num_of_nodes, dtype=np.uint64)
        coll_dend = coll_ax.copy()
        dist_ax = np.zeros(self.num_of_nodes, dtype=np.float64)
        dist_dend = dist_ax.copy()
        self.parsed_axon = pd.DataFrame({"coll": coll_ax, "dist": dist_ax})
        self.parsed_dend = pd.DataFrame({"coll": coll_dend, "dist": dist_dend})

    @classmethod
    def from_graph(cls, fname: pathlib.Path, neuron: str):
        """Instantiate from an existing graph file by deserializing it."""
        try:
            graph = nx.readwrite.gml.read_gml(
                str(fname), destringizer=CollisionNode.from_str
            )
        except FileNotFoundError:
            raise
        else:
            return cls(graph, neuron)

    def run(self):
        """Run analysis pipeline."""
        self._populate_collisions()
        self.parsed_axon["coll_normed"] = self._normalize_by_density(self.parsed_axon)
        self.parsed_dend["coll_normed"] = self._normalize_by_density(self.parsed_dend)

    def _populate_collisions(self):
        """Traverse a specific graph and find the number of
        collisions in it as a function of the topological distance
        from the cell body.
        """
        idx_axon, idx_dend = 0, 0
        for node in self.graph.nodes():
            if node.tree_type == "Axon":
                self.parsed_axon.loc[idx_axon, "coll"] = (
                    node.collisions / self.normalize_collisions_by
                )
                self.parsed_axon.loc[idx_axon, "dist"] = node.dist_to_body
                idx_axon += 1
            else:
                self.parsed_dend.loc[idx_dend, "coll"] = (
                    node.collisions / self.normalize_collisions_by
                )
                self.parsed_dend.loc[idx_dend, "dist"] = node.dist_to_body
                idx_dend += 1

        self.parsed_axon = self.parsed_axon.loc[:idx_axon, :]
        self.parsed_dend = self.parsed_dend.loc[:idx_dend, :]

    def _normalize_by_density(self, data):
        """Takes the parsed graph data and normalizes the collision counts by the
        neural density at that distance, since the more neuron there is the more likely
        it is for it to encounter blood vessels. This function actually returns the chance
        for a (normalized) collision, since it also divided the result by the number of
        NCD iterations.
        """
        dist_int = data["dist"].to_numpy().astype(np.int64)
        bincounts = np.bincount(dist_int, minlength=dist_int.max())
        normed = norm_colls(bincounts, dist_int, data["coll"].to_numpy())
        return normed

    def plot_all(self):
        """Small wrapper for plotting with all configs."""
        for data, neurite in zip(
            (self.parsed_axon, self.parsed_dend), ("axon", "dend")
        ):
            self._plot_jointplot(data, neurite, with_norm=False)
            self._plot_jointplot(data, neurite, with_norm=True)

    def _plot_jointplot(self, data, neurite, with_norm=False):
        """Creates a jointplot with hexagons which show the probability of collision
        as a function of the topological distance from the soma.
        """
        labels_and_colors = {"axon": ("C2", "Axonal"), "dend": ("C1", "Dendritic")}
        new_ycol_name = f"{labels_and_colors[neurite][1]} chance for collision"
        data = data.copy().rename(
            {
                "dist": "Length of branch [um]",
                "coll": new_ycol_name,
                "coll_normed": f"{new_ycol_name} (normalized)",
            },
            axis=1,
        )
        if with_norm:
            y_col = new_ycol_name + " (normalized)"
            fname = f"results/for_article/fig2/{self.neuron_name}_colls_vs_dist_normed_{neurite}.pdf"
        else:
            y_col = new_ycol_name
            fname = f"results/for_article/fig2/{self.neuron_name}_colls_vs_dist_no_normed_{neurite}.pdf"

        ax = sns.jointplot(
            "Length of branch [um]",
            y_col,
            data=data,
            kind="hex",
            height=8,
            color=labels_and_colors[neurite][0],
        )
        plt.subplots_adjust(left=0.11)
        ax.savefig(
            fname, transparent=True, dpi=300,
        )


@attr.s
class AggregateDistributions:
    """Sum up all of the neuron's collision density into two groups -
    layer 2/3 and the rest - and show the distributions.
    """

    l23_neurons = attr.ib(validator=instance_of(list))
    rest_of_neurons = attr.ib(validator=instance_of(list))
    colors = attr.ib(init=False)

    def run_all_cells(self):
        """Main class method."""
        l23_ax_lines, l23_dend_lines, rest_ax_lines, rest_dend_lines = [], [], [], []
        for idx, neuron in enumerate(self.l23_neurons):
            print(neuron)
            lines = self.run_on_single_cell(neuron, idx, is_23=True)
            if lines:
                l23_ax_lines.append(lines[0])
                l23_dend_lines.append(lines[1])

        for idx, neuron in enumerate(self.rest_of_neurons):
            print(neuron)
            lines = self.run_on_single_cell(neuron, idx, is_23=False)
            if lines:
                rest_ax_lines.append(lines[0])
                rest_dend_lines.append(lines[1])

        fig, axes = plt.subplots(4, 1, sharex=True)
        for ax, lines in zip(
            axes, (l23_ax_lines, rest_ax_lines, l23_dend_lines, rest_dend_lines)
        ):
            self._create_figure(ax, lines)

        return axes

    def run_on_single_cell(self, name, idx, is_23):
        """Short pipeline to process single cell graphs."""
        try:
            coll_dist = CollisionsDistNaive.from_graph(name_to_graph_fname(name), name)
        except FileNotFoundError:
            return
        coll_dist.run()
        line_ax = self._gen_line2d(coll_dist, "axon", idx, is_23)
        line_dend = self._gen_line2d(coll_dist, "dend", idx, is_23)
        return (line_ax, line_dend)

    def _gen_line2d(self, coll_dist, neurite, idx, is_23):
        data = getattr(coll_dist, "parsed_" + neurite)
        x_data = np.linspace(0, 1000, len(data))
        y_data = data["coll_normed"] - data["coll_normed"].min()
        y_data /= data["coll_normed"].max()
        linewidth = 2
        linestyle = "-" if is_23 else "--"
        color = "C2" if neurite == "axon" else "C1"
        return plt.Line2D(x_data, y_data, linewidth, linestyle, color)

    def _create_figure(self, ax, lines):
        """Adds a mpl.Line2D to the given axes, and changes their appearance."""
        ax.spines["top"].set_visible(False)
        ax.spines["right"].set_visible(False)
        ax.spines["left"].set_visible(False)
        ax.get_xaxis().tick_bottom()
        ax.get_yaxis().tick_left()
        ax.set_xlabel("Length of branch [AU]")
        ax.set_yticks([])
        ax.set_xticks([])
        ax.set_ylim((0, 1))
        [ax.add_line(line) for line in lines]


@numba.jit(nopython=True, parallel=True)
def norm_colls(bincounts, distances, collisions):
    """Iterate over the collision counts and normalize
    them by the neural density at that distance.
    """
    normed_collisions = np.zeros_like(collisions)
    for idx in numba.prange(len(collisions)):
        normed_collisions[idx] = collisions[idx] / bincounts[distances[idx]]
    return normed_collisions


def name_to_graph_fname(neuron):
    return (
        pathlib.Path("/data/neural_collision_detection/results/2019_2_10")
        / f"graph_{neuron}_with_collisions.gml"
    )


if __name__ == "__main__":
    plt.rcParams.update({"font.size": 22})
    neuron_names = [
        "AP120410_s1c1",
        "AP120410_s3c1",
        "AP120412_s3c2",
        "AP120416_s3c1",
        "AP120419_s1c1",
        "AP120420_s1c1",
        "AP120420_s2c1",
        "AP120507_s3c1",
        "AP120510_s1c1",
        "AP120522_s3c1",
        "AP120524_s2c1",
        "AP120614_s1c2",
        "AP130312_s1c1",
        "AP131105_s1c1",
    ]
    rest_of_neurons = neuron_names.copy()
    l23_neurons_idx = [-1, -4, 7, 8, 6, -2]
    l23_neurons = list(rest_of_neurons.pop(idx) for idx in l23_neurons_idx)

    # for neuron in neuron_names:
    #     graph_fname = name_to_graph_fname(neuron)
    #     try:
    #         coll_dist = CollisionsDistNaive.from_graph(graph_fname, neuron)
    #     except FileNotFoundError:
    #         continue
    #     coll_dist.run()
    #     coll_dist.plot_all()
    agg = AggregateDistributions(l23_neurons, rest_of_neurons)
    ax = agg.run_all_cells()
    plt.show(block=False)
