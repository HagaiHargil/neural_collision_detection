"""
Aggregation of tools to analyze the graphs generated by
'graph_parsing.py'.
"""
import pathlib

import attr
from attr.validators import instance_of
import networkx as nx
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import scipy.stats
import numba

from ncd_post_process.graph_parsing import CollisionNode


@attr.s
class CollisionsDistNaive:
    """Calculate and plot the collision counts as a function of
    the topological distance of the neuron. This class is "naive" since it doesn't
    interpolate the neural coordinates, it uses the raw output from the
    Neurolucida files as its input.

    To use it, run the "run" method to first create the necessary data structures.
    The "plot_all()" method can show the data and write it to disk.

    Parameters
    ----------
    graph : nx.Graph
        A parsed graph that was generated by networkx and ``NeuronToGraph`` in
        ``graph_parsing.py``.
    neuron_name : str
        The label of the neuron
    normalize_collisions_by : int
        Number of possible locations that the neuron could've been in. This factor turns
        the number of collisions into the probability of collision.
    """

    graph = attr.ib(validator=instance_of(nx.Graph))
    neuron_name = attr.ib(default="neuron", validator=instance_of(str))
    normalize_collisions_by = attr.ib(default=100_000, validator=instance_of(int))
    num_of_nodes = attr.ib(init=False)
    parsed_axon = attr.ib(init=False)
    parsed_dend = attr.ib(init=False)
    labels_and_colors = attr.ib(init=False)

    def __attrs_post_init__(self):
        self.num_of_nodes = self.graph.number_of_nodes()
        coll_ax = np.zeros(self.num_of_nodes, dtype=np.uint64)
        coll_dend = coll_ax.copy()
        dist_ax = np.zeros(self.num_of_nodes, dtype=np.float64)
        dist_dend = dist_ax.copy()
        self.parsed_axon = pd.DataFrame({"coll": coll_ax, "dist": dist_ax})
        self.parsed_dend = pd.DataFrame({"coll": coll_dend, "dist": dist_dend})
        self.labels_and_colors = {"axon": ("C2", "Axonal", "Greens"), "dend": ("C1", "Dendritic", "Oranges")}


    @classmethod
    def from_graph(cls, fname: pathlib.Path, neuron: str):
        """Instantiate from an existing graph file by deserializing it."""
        try:
            graph = nx.readwrite.gml.read_gml(
                str(fname), destringizer=CollisionNode.from_str
            )
        except FileNotFoundError:
            raise
        else:
            return cls(graph, neuron)

    def run(self):
        """Run analysis pipeline."""
        self._populate_collisions()
        self.parsed_axon["coll_normed"] = self._normalize_by_density(self.parsed_axon)
        self.parsed_dend["coll_normed"] = self._normalize_by_density(self.parsed_dend)

    def _populate_collisions(self):
        """Traverse a specific graph and find the number of
        collisions in it as a function of the topological distance
        from the cell body.
        """
        idx_axon, idx_dend = 0, 0
        for node in self.graph.nodes():
            if node.tree_type == "Axon":
                self.parsed_axon.loc[idx_axon, "coll"] = (
                    node.collisions / self.normalize_collisions_by
                )
                self.parsed_axon.loc[idx_axon, "dist"] = node.dist_to_body
                idx_axon += 1
            else:
                self.parsed_dend.loc[idx_dend, "coll"] = (
                    node.collisions / self.normalize_collisions_by
                )
                self.parsed_dend.loc[idx_dend, "dist"] = node.dist_to_body
                idx_dend += 1

        self.parsed_axon = self.parsed_axon.loc[:idx_axon, :]
        self.parsed_dend = self.parsed_dend.loc[:idx_dend, :]

    def _normalize_by_density(self, data):
        """Takes the parsed graph data and normalizes the collision counts by the
        neural density at that distance, since the more neuron there is the more likely
        it is for it to encounter blood vessels. This function actually returns the chance
        for a (normalized) collision, since it also divided the result by the number of
        NCD iterations.
        """
        dist_int = data["dist"].to_numpy().astype(np.int64)
        bincounts = np.bincount(dist_int, minlength=dist_int.max())
        normed = norm_colls(bincounts, dist_int, data["coll"].to_numpy())
        return normed

    def plot_all_jointplots(self):
        """Small wrapper for plotting the full jointplot of
        all cells and both axons and dendrites."""
        for data, neurite in zip(
            (self.parsed_axon, self.parsed_dend), ("axon", "dend")
        ):
            self._plot_jointplot(data, neurite, with_norm=False)
            self._plot_jointplot(data, neurite, with_norm=True)

    def plot_all_hexbins(self):
        """Small wrapper for plotting the only the hexbin
        all cells and both axons and dendrites."""
        for data, neurite in zip((self.parsed_axon, self.parsed_dend), ("axon", "dend")):
            self._plot_hexbin(data, neurite, with_norm=True)

    def _plot_jointplot(self, data, neurite, with_norm=False):
        """Creates a jointplot with hexagons which show the probability of collision
        as a function of the topological distance from the soma.
        """
        new_ycol_name = f"{self.labels_and_colors[neurite][1]} chance for collision"
        data = data.copy().rename(
            {
                "dist": "Length of branch [um]",
                "coll": new_ycol_name,
                "coll_normed": f"{new_ycol_name} (normalized)",
            },
            axis=1,
        )
        if with_norm:
            y_col = new_ycol_name + " (normalized)"
            fname = f"results/for_article/fig2/{self.neuron_name}_colls_vs_dist_normed_{neurite}.pdf"
        else:
            y_col = new_ycol_name
            fname = f"results/for_article/fig2/{self.neuron_name}_colls_vs_dist_no_normed_{neurite}.pdf"

        ax = sns.jointplot(
            "Length of branch [um]",
            y_col,
            data=data,
            kind="hex",
            height=8,
            color=self.labels_and_colors[neurite][0],
        )
        plt.subplots_adjust(left=0.11)
        ax.savefig(
            fname, transparent=True, dpi=300,
        )

    def _plot_hexbin(self, data, neurite, with_norm=False):
        """Plots a hexbin plot of the data."""
        new_ycol_name = f"{self.labels_and_colors[neurite][1]} chance for collision"
        data = data.copy().rename(
            {
                "dist": "Length of branch [um]",
                "coll": new_ycol_name,
                "coll_normed": f"{new_ycol_name} (normalized)",
            },
            axis=1,
        )
        if with_norm:
            y_col = new_ycol_name + " (normalized)"
            normed = "normed"
        else:
            y_col = new_ycol_name
            normed = "not_normed"

        x = data["Length of branch [um]"]
        y = data[y_col]
        ymin = 0
        ymax = max(y.max() * 1.1, y.mean() * 4)
        extent = (x.min(), x.max(), ymin, ymax)
        fig, ax = plt.subplots(figsize=(8, 8))
        ax.hexbin(x, y, gridsize=30, cmap=self.labels_and_colors[neurite][2], mincnt=1, extent=extent)
        ax.axis('off')

        fname = f"results/for_article/fig2/{self.neuron_name}_colls_vs_dist_only_hexbin_{normed}_{neurite}.png"
        fig.savefig(fname, transparent=True, dpi=300)


@numba.jit(nopython=True, parallel=True)
def norm_colls(bincounts, distances, collisions):
    """Iterate over the collision counts and normalize
    them by the neural density at that distance.
    """
    normed_collisions = np.zeros_like(collisions)
    for idx in numba.prange(len(collisions)):
        normed_collisions[idx] = collisions[idx] / bincounts[distances[idx]]
    return normed_collisions


def name_to_graph_fname(neuron):
    return (
        pathlib.Path("/data/neural_collision_detection/results/2019_2_10")
        / f"graph_{neuron}_with_collisions.gml"
    )


if __name__ == "__main__":
    plt.rcParams.update({"font.size": 22})
    neuron_names = [
        "AP120410_s1c1",
        "AP120410_s3c1",
        "AP120412_s3c2",
        "AP120416_s3c1",
        "AP120419_s1c1",
        "AP120420_s1c1",
        "AP120420_s2c1",
        "AP120507_s3c1",
        "AP120510_s1c1",
        "AP120522_s3c1",
        "AP120524_s2c1",
        "AP120614_s1c2",
        "AP130312_s1c1",
        "AP131105_s1c1",
    ]
    # rest_of_neurons = neuron_names.copy()
    # l23_neurons_idx = [-1, -4, 7, 8, 6, -2]
    # l23_neurons = list(rest_of_neurons.pop(idx) for idx in l23_neurons_idx)

    for neuron in neuron_names:
        graph_fname = name_to_graph_fname(neuron)
        try:
            coll_dist = CollisionsDistNaive.from_graph(graph_fname, neuron)
        except FileNotFoundError:
            continue
        coll_dist.run()
    #     coll_dist.plot_all_jointplots()
        coll_dist.plot_all_hexbins()
    # agg = AggregateDistributions(l23_neurons, rest_of_neurons)
    # ax = agg.run_all_cells()
    plt.show(block=False)
